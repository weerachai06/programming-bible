#!/usr/bin/env node

/**
 * JSDoc validation script for the project.
 *
 * This script validates JSDoc comments across the project to ensure
 * consistency and completeness.
 *
 * @fileoverview JSDoc validation script
 * @author Generated by migration script
 * @since 1.0.0
 */

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

/**
 * Configuration for JSDoc validation.
 *
 * @typedef {Object} ValidationConfig
 * @property {string[]} extensions - File extensions to validate
 * @property {string[]} ignorePaths - Paths to ignore during validation
 * @property {Object} rules - Validation rules
 */
const config = {
  extensions: ['.js', '.jsx', '.ts', '.tsx'],
  ignorePaths: [
    'node_modules',
    '.next',
    'dist',
    'build',
    'coverage',
    'docs',
    'public',
  ],
  rules: {
    requireJSDocForPublicFunctions: true,
    requireParamDescriptions: true,
    requireReturnDescriptions: true,
    requireExamplesForComplexFunctions: true,
    checkParamTypeConsistency: true,
  },
}

/**
 * Represents a JSDoc validation issue.
 *
 * @typedef {Object} ValidationIssue
 * @property {string} file - File path where the issue was found
 * @property {number} line - Line number of the issue
 * @property {string} type - Type of validation issue
 * @property {string} message - Description of the issue
 * @property {string} severity - Severity level (error, warning, info)
 */

/**
 * Main validation function.
 *
 * @async
 * @function validateJSDoc
 * @returns {Promise<ValidationIssue[]>} Array of validation issues found
 *
 * @example
 * // Run validation
 * const issues = await validateJSDoc();
 * console.log(`Found ${issues.length} issues`);
 *
 * @since 1.0.0
 */
async function validateJSDoc() {
  const issues = []
  const projectRoot = path.join(__dirname, '..')

  try {
    const files = await getProjectFiles(projectRoot)

    for (const file of files) {
      const fileIssues = await validateFile(file)
      issues.push(...fileIssues)
    }

    return issues
  } catch (error) {
    console.error('Error during JSDoc validation:', error)
    return []
  }
}

/**
 * Get all project files that should be validated.
 *
 * @async
 * @function getProjectFiles
 * @param {string} rootPath - Root path to search for files
 * @returns {Promise<string[]>} Array of file paths to validate
 *
 * @since 1.0.0
 */
async function getProjectFiles(rootPath) {
  const files = []

  /**
   * Recursively walk directory tree.
   *
   * @param {string} currentPath - Current directory path
   * @returns {Promise<void>}
   */
  async function walkDir(currentPath) {
    const entries = await fs.promises.readdir(currentPath, {
      withFileTypes: true,
    })

    for (const entry of entries) {
      const fullPath = path.join(currentPath, entry.name)

      if (entry.isDirectory()) {
        // Skip ignored directories
        if (
          !config.ignorePaths.some(ignorePath => fullPath.includes(ignorePath))
        ) {
          await walkDir(fullPath)
        }
      } else if (entry.isFile()) {
        // Check if file has valid extension
        const ext = path.extname(entry.name)
        if (config.extensions.includes(ext)) {
          files.push(fullPath)
        }
      }
    }
  }

  await walkDir(rootPath)
  return files
}

/**
 * Validate JSDoc comments in a single file.
 *
 * @async
 * @function validateFile
 * @param {string} filePath - Path to the file to validate
 * @returns {Promise<ValidationIssue[]>} Array of issues found in the file
 *
 * @since 1.0.0
 */
async function validateFile(filePath) {
  const issues = []

  try {
    const content = await fs.promises.readFile(filePath, 'utf8')
    const lines = content.split('\n')

    // Find function declarations
    const functionRegex = /^(?:export\s+)?(?:async\s+)?function\s+(\w+)\s*\(/gm
    const classRegex = /^(?:export\s+)?class\s+(\w+)/gm
    const interfaceRegex = /^(?:export\s+)?interface\s+(\w+)/gm

    // Check functions
    let match
    while ((match = functionRegex.exec(content)) !== null) {
      const functionName = match[1]
      const lineNumber = content.substring(0, match.index).split('\n').length

      // Check if function has JSDoc
      if (!hasJSDocComment(content, match.index)) {
        issues.push({
          file: filePath,
          line: lineNumber,
          type: 'missing-jsdoc',
          message: `Function '${functionName}' is missing JSDoc comment`,
          severity: 'error',
        })
      }
    }

    // Check classes
    while ((match = classRegex.exec(content)) !== null) {
      const className = match[1]
      const lineNumber = content.substring(0, match.index).split('\n').length

      if (!hasJSDocComment(content, match.index)) {
        issues.push({
          file: filePath,
          line: lineNumber,
          type: 'missing-jsdoc',
          message: `Class '${className}' is missing JSDoc comment`,
          severity: 'error',
        })
      }
    }

    // Check interfaces (TypeScript)
    while ((match = interfaceRegex.exec(content)) !== null) {
      const interfaceName = match[1]
      const lineNumber = content.substring(0, match.index).split('\n').length

      if (!hasJSDocComment(content, match.index)) {
        issues.push({
          file: filePath,
          line: lineNumber,
          type: 'missing-jsdoc',
          message: `Interface '${interfaceName}' is missing JSDoc comment`,
          severity: 'warning',
        })
      }
    }

    return issues
  } catch (error) {
    console.error(`Error validating file ${filePath}:`, error)
    return []
  }
}

/**
 * Check if a declaration has a JSDoc comment.
 *
 * @function hasJSDocComment
 * @param {string} content - File content
 * @param {number} declarationIndex - Index of the declaration
 * @returns {boolean} Whether the declaration has a JSDoc comment
 *
 * @since 1.0.0
 */
function hasJSDocComment(content, declarationIndex) {
  // Look backwards for JSDoc comment
  const beforeDeclaration = content.substring(0, declarationIndex)
  const lines = beforeDeclaration.split('\n')

  // Check the last few lines for JSDoc
  for (let i = lines.length - 1; i >= Math.max(0, lines.length - 10); i--) {
    const line = lines[i].trim()
    if (line === '*/') {
      // Found end of JSDoc, now look for start
      for (let j = i - 1; j >= 0; j--) {
        const prevLine = lines[j].trim()
        if (prevLine.startsWith('/**')) {
          return true
        }
        if (!prevLine.startsWith('*') && prevLine !== '') {
          break
        }
      }
    }
    if (line !== '' && !line.startsWith('*') && !line.startsWith('//')) {
      break
    }
  }

  return false
}

/**
 * Format and display validation results.
 *
 * @function displayResults
 * @param {ValidationIssue[]} issues - Array of validation issues
 * @returns {void}
 *
 * @since 1.0.0
 */
function displayResults(issues) {
  if (issues.length === 0) {
    console.log('âœ… No JSDoc validation issues found!')
    return
  }

  console.log(`âŒ Found ${issues.length} JSDoc validation issues:\n`)

  // Group issues by file
  const issuesByFile = issues.reduce((acc, issue) => {
    if (!acc[issue.file]) {
      acc[issue.file] = []
    }
    acc[issue.file].push(issue)
    return acc
  }, {})

  // Display issues by file
  for (const [file, fileIssues] of Object.entries(issuesByFile)) {
    console.log(`ðŸ“„ ${path.relative(process.cwd(), file)}`)

    for (const issue of fileIssues) {
      const severityIcon =
        issue.severity === 'error'
          ? 'ðŸ”´'
          : issue.severity === 'warning'
            ? 'ðŸŸ¡'
            : 'ðŸ”µ'
      console.log(`  ${severityIcon} Line ${issue.line}: ${issue.message}`)
    }

    console.log('')
  }

  // Summary
  const errorCount = issues.filter(i => i.severity === 'error').length
  const warningCount = issues.filter(i => i.severity === 'warning').length
  const infoCount = issues.filter(i => i.severity === 'info').length

  console.log('ðŸ“Š Summary:')
  if (errorCount > 0) console.log(`  ðŸ”´ ${errorCount} errors`)
  if (warningCount > 0) console.log(`  ðŸŸ¡ ${warningCount} warnings`)
  if (infoCount > 0) console.log(`  ðŸ”µ ${infoCount} info`)
}

// Run validation if this script is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  validateJSDoc()
    .then(issues => {
      displayResults(issues)
      process.exit(
        issues.filter(i => i.severity === 'error').length > 0 ? 1 : 0
      )
    })
    .catch(error => {
      console.error('Fatal error during validation:', error)
      process.exit(1)
    })
}

export { displayResults, getProjectFiles, validateFile, validateJSDoc }
